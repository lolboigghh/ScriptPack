if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end local Player,game,owner = owner,game local RealPlayer = Player do     local rp = RealPlayer     local Event = Instance.new("RemoteEvent")  Event.Name = "UserInput_Event"    local function fakeEvent()        local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}        t.connect = t.Connect       return t    end   local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}   local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}   local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)       CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil   end}    CAS.UnbindAction = CAS.BindAction    local function te(self,ev,...)      local t = m[ev]       if t and t._fakeEvent then           for _,f in pairs(t.Functions) do               f(...)           end       end    end    m.TrigEvent = te    UIS.TrigEvent = te    Event.OnServerEvent:Connect(function(plr,io)        if plr~=rp then return end        m.Target = io.Target        m.Hit = io.Hit        if not io.isMouse then            local b = io.UserInputState == Enum.UserInputState.Begin            if io.UserInputType == Enum.UserInputType.MouseButton1 then                return m:TrigEvent(b and "Button1Down" or "Button1Up")            end            for _,t in pairs(CAS.Actions) do                for _,k in pairs(t.Keys) do                    if k==io.KeyCode then                       t.Function(t.Name,io.UserInputState,io)                   end                end            end           m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())            UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)        end    end)    Event.Parent = NLS([==[    local Player = game:GetService("Players").LocalPlayer    local Event = script:WaitForChild("UserInput_Event")     local Mouse = Player:GetMouse()    local UIS = game:GetService("UserInputService")    local input = function(io,a)        if a then return end Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})    end    UIS.InputBegan:Connect(input)    UIS.InputEnded:Connect(input)    local h,t    while wait(1/30) do        if h~=Mouse.Hit or t~=Mouse.Target then            h,t=Mouse.Hit,Mouse.Target           Event:FireServer({isMouse=true,Target=t,Hit=h})        end    end]==],Player.PlayerGui)    local _rg = game    local fsmt = {       __index = function(self,k)            local s = rawget(self,"_RealService")            if s then return s[k] end        end,        __newindex = function(self,k,v)            local s = rawget(self,"_RealService")            if s then s[k]=v end        end,        __call = function(self,...)            local s = rawget(self,"_RealService")            if s then return s(...) end        end    }    local function FakeService(t,RealService)        t._RealService = typeof(RealService)=="string" and _rg:GetService(RealService) or RealService        return setmetatable(t,fsmt)    end    local g = {        GetService = function(self,s)            return self[s]        end,        Players = FakeService({            LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)        },"Players"),        UserInputService = FakeService(UIS,"UserInputService"),        ContextActionService = FakeService(CAS,"ContextActionService"),    }    rawset(g.Players,"localPlayer",g.Players.LocalPlayer)    g.service = g.GetService       g.RunService = FakeService({        RenderStepped = _rg:GetService("RunService").Heartbeat,        BindToRenderStep = function(self,name,_,fun)            self._btrs[name] = self.Heartbeat:Connect(fun)        end,        UnbindFromRenderStep = function(self,name)            self._btrs[name]:Disconnect()        end,    },"RunService")     setmetatable(g,{        __index=function(self,s)            return _rg:GetService(s) or typeof(_rg[s])=="function"            and function(_,...)return _rg[s](_rg,...)end or _rg[s]        end,        __newindex = fsmt.__newindex,        __call = fsmt.__call    })    game,owner = g,g.Players.LocalPlayer end
print("Loaded FreddyC4 By lolboigghh.")
warn("Steal = no mom.")
local fragmentable = script
local tick = Instance.new("Sound")
tick.SoundId = "rbxasset://sounds\\clickfast.wav"
tick.Parent = game:GetService("VRService")
tick.Volume = 2
tick.EmitterSize = 10
tick.PlayOnRemove = true
local activate = Instance.new("Sound")
activate.SoundId = "rbxassetid://9070807695"
activate.Parent = game:GetService("VRService")
activate.Volume = 2
activate.EmitterSize = 10
activate.PlayOnRemove = true
local rocketexp = Instance.new("Sound", game:GetService("VRService"))
rocketexp.SoundId = 'rbxassetid://252142019'
rocketexp.Volume = 5
rocketexp.PlayOnRemove = true
rocketexp.EmitterSize = 10
local m = owner:GetMouse()
local Tool0 = Instance.new("Tool", owner.Backpack)
Tool0.Name = "C4 Place"
Tool0.Grip = CFrame.new(-1.23, 0, -.5) * CFrame.Angles(math.rad(90), math.rad(180), 0)
Tool0.CanBeDropped = false
local SpecialMesh2 = Instance.new("SpecialMesh")
local Part1 = Instance.new("SpawnLocation")
Part1.Name = "Handle"
Part1.Enabled = false
Part1.Parent = Tool0
Part1.Size = Vector3.new(1.59000003, .681999981, 2.26300001)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
SpecialMesh2.Parent = Part1
SpecialMesh2.MeshId = "rbxassetid://525186249"
SpecialMesh2.Scale = Vector3.new(.00200000009, .00200000009, .00200000009)
SpecialMesh2.TextureId = "rbxassetid://525186273"
SpecialMesh2.MeshType = Enum.MeshType.FileMesh
local c4s = {}
local function lookat(part, pos, normal) 
local p1 = part.CFrame.lookVector:Cross(normal)
return CFrame.fromMatrix(pos, p1, normal)
end
local function Place()
local params = RaycastParams.new()
params.FilterDescendantsInstances = {owner.Character, Tool0, Part1}
local dir = (m.Hit.p - Part1.CFrame.p)
local res = workspace:Raycast(Part1.CFrame.p, dir*100000)
if res and res.Instance and res.Instance:IsDescendantOf(owner.Character) == false then
local c4 = Part1:Clone()
c4.Parent = script
c4.Name = "C4"
c4.CFrame = lookat(c4, res.Position, res.Normal)
local w = Instance.new("WeldConstraint", c4)
w.Part0 = c4
w.Part1 = res.Instance
local pl = Instance.new("PointLight", c4)
pl.Range = 8
pl.Brightness = 15
pl.Name = "PointLight"
pl.Color = Color3.new(1, 0, 0)
pl.Enabled = true
c4:SetAttribute("Active", 0)
coroutine.wrap(function()
while task.wait(1) do
if c4:GetAttribute("Active") ~= 0 then break end
pl.Enabled = true
tick.Parent = c4
tick.Parent = nil
task.wait(.5)
if c4:GetAttribute("Active") ~= 0 then break end
pl.Enabled = false
task.wait(.5)
end
end)()
table.insert(c4s, c4)
end
end
Tool0.Activated:Connect(function()
Place()
end)
local Tool0 = Instance.new("Tool", owner.Backpack)
Tool0.Name = "C4 Detonate"
Tool0.Grip = CFrame.new(0, .1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
Tool0.CanBeDropped = false
local SpecialMesh2 = Instance.new("SpecialMesh")
local Part1 = Instance.new("SpawnLocation")
Part1.Name = "Handle"
Part1.Enabled = false
Part1.Parent = Tool0
Part1.Size = Vector3.new(.4, .39, 1.98)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
SpecialMesh2.Parent = Part1
SpecialMesh2.MeshId = "rbxassetid://74322546"
SpecialMesh2.TextureId = "rbxassetid://74322558"
SpecialMesh2.Scale = Vector3.new(1.5, 1.5, 1.5)
SpecialMesh2.MeshType = Enum.MeshType.FileMesh
local function HasHumanoid(p)
if p:FindFirstAncestorOfClass("Model", true) and p:FindFirstAncestorOfClass("Model", true):FindFirstChildOfClass("Humanoid") then
return p:FindFirstAncestorOfClass("Model", true):FindFirstChildOfClass("Humanoid")
else
return false
end
end
local function BreakJoints(model)
for i, v in pairs(model:GetDescendants()) do
if v:IsA("JointInstance") then
v.Enabled = false
v:Destroy()
end
end
end
local Vectors = {"UpVector", "RightVector", "LookVector"}
local function FlingModel(model)
for i, v in pairs(model:GetDescendants()) do
if v:IsA("BasePart") then
local m = math.random(-1, 1)
v.Anchored = false
v.Velocity = v.CFrame[Vectors[math.random(1, #Vectors)]] * (350 * m)
end
end
end
local list = {}
local yieldafter = 3
local minimumsize = Vector3.new(1, 1, 1) * 1.25
function fragmentate(cframe, size, c, explosion_position, explosion_blastradius, backsurface, bottomsurface, frontsurface, leftsurface, rightsurface, topsurface, transparency, reflectance, material, anchored, heck, ree, same)
local tbl = {c[1],c[2],c[3]}
local parts = {}
local color = c[2]
    local xi = size.X >= minimumsize.X*(1+explosion_blastradius/16) and 2 or 1
    local yi = size.Y >= minimumsize.Y*(1+explosion_blastradius/16) and 2 or 1
    local zi = size.Z >= minimumsize.Z*(1+explosion_blastradius/16) and 2 or 1
    if xi == 1 and yi == 1 and zi == 1 or (cframe.p-explosion_position).magnitude > size.magnitude/2 + explosion_blastradius then
        if xi == 1 and yi == 1 and zi == 1 then return end
            local p = Instance.new("SpawnLocation", c[1]) p.Enabled = false
            p.BrickColor = color
            p.FormFactor = "Custom" table.insert(parts, p) p.Name = c[3].. " bit"
            if heck then
                p.Anchored = anchored
            else
                p.Anchored = true
            end
            p.Size = size
            p.BackSurface = backsurface
            p.BottomSurface = bottomsurface
            p.FrontSurface = frontsurface
            p.LeftSurface = leftsurface
            p.RightSurface = rightsurface
            if heck ~= true or ree == true then
                local int = Instance.new('IntValue',p)
                int.Name = 'already broken u pleb'
            end
            p.TopSurface = topsurface
            if redmode and ree and same ~= true then
                task.spawn(function()
                    repeat
                        p.Color = Color3.new(1,0,0)
                        p.Material = Enum.Material.Neon
                        task.wait()
                    until p.Color == Color3.new(1,0,0) and p.Material == Enum.Material.Neon
                end)
            end
            p.Transparency = transparency
            p.Material = material
            if heck ~= true or ree then
                -- game:GetService('Debris'):AddItem(p,10)
            end
            p.CFrame = cframe
            p.Reflectance = reflectance
            p:BreakJoints()
        return
    end
    local mody = math.random(-125,125)/1000
    for y = 1,yi do if y % yieldafter == 0 then task.wait(.05) end
        if math.random()> 0.5 then
            local modx = math.random(-125,125)/1000
            for x = 1,xi do
                local modz = math.random(-125,125)/1000
                for z = 1,zi do --offset = x/xi-0.75+modx)
                    fragmentate(cframe*CFrame.new(size.X*(xi==1 and 0 or x/xi-0.75+modx),size.Y*(yi==1 and 0 or y/yi-0.75+mody),size.Z*(zi==1 and 0 or z/zi-0.75+modz)),
                        Vector3.new(xi == 2 and size.X*(1-2*math.abs(x/xi-0.75+modx)) or size.X,yi == 2 and size.Y*(1-2*math.abs(y/yi-0.75+mody)) or size.Y,
                        zi == 2 and size.Z*(1-2*math.abs(z/zi-0.75+modz)) or size.Z),tbl,explosion_position,explosion_blastradius,
                        z~=zi and surface_between_splitted_parts or backsurface,y==2 and surface_between_splitted_parts or bottomsurface,
                        z==2 and surface_between_splitted_parts or frontsurface,x==2 and surface_between_splitted_parts or leftsurface,x~=xi and surface_between_splitted_parts or rightsurface,
                        y~=yi and surface_between_splitted_parts or topsurface,transparency,reflectance,material,anchored,heck,ree,same)
                end
               
            end
        else
            local modz = math.random(-125,125)/1000
            for z = 1,zi do if z % yieldafter == 0 then task.wait(.05) end
                local modx = math.random(-125,125)/1000
                for x = 1,xi do
                    fragmentate(cframe*CFrame.new(size.X*(xi==1 and 0 or x/xi-0.75+modx),size.Y*(yi==1 and 0 or y/yi-0.75+mody),size.Z*(zi==1 and 0 or z/zi-0.75+modz)),
                        Vector3.new(xi == 2 and size.X*(1-2*math.abs(x/xi-0.75+modx)) or size.X,yi == 2 and size.Y*(1-2*math.abs(y/yi-0.75+mody)) or size.Y,
                        zi == 2 and size.Z*(1-2*math.abs(z/zi-0.75+modz)) or size.Z),tbl,explosion_position,explosion_blastradius,
                        z~=zi and surface_between_splitted_parts or backsurface,y==2 and surface_between_splitted_parts or bottomsurface,
                        z==2 and surface_between_splitted_parts or frontsurface,x==2 and surface_between_splitted_parts or leftsurface,x~=xi and surface_between_splitted_parts or rightsurface,
                        y~=yi and surface_between_splitted_parts or topsurface,transparency,reflectance,material,anchored,heck,ree,same)
                end
            end
        end
    end    
end
 
function start_fragmentation(position,radius,bigoof,smoloof,samecolor)
    local search = Region3.new(position-Vector3.new(radius,radius,radius)*1.1,position+Vector3.new(radius,radius,radius)*1.1)
    
    repeat
    local finish = false
    local parts = workspace:FindPartsInRegion3WithIgnoreList(search,list,100)
    for i = 1, #parts do
        table.insert(list, parts[i])
    end
    finish = true
    until #parts and finish
    for i, p in pairs(list) do
        if p:IsDescendantOf(owner.Character) == false then
local parent = p.Parent
local anch = p.Anchored
local tbl = {parent,p.BrickColor,p.Name}
p:Destroy()
fragmentate(p.CFrame,p.Size,tbl,position,radius,p.BackSurface,p.BottomSurface,p.FrontSurface,p.LeftSurface,p.RightSurface,p.TopSurface,p.Transparency,p.Reflectance,p.Material,anch,bigoof,smoloof,samecolor)
        end
    end
    list = {}
end
local function Explode(guy)
-- pcall(function()
local exp = Instance.new("Explosion", script)
exp.Position = guy.Position
exp.BlastRadius = 15
exp.BlastPressure = 500000
exp.ExplosionType = "CratersAndDebris"
exp.DestroyJointRadiusPercent = 0
rocketexp.Parent = guy
rocketexp.Parent = nil
start_fragmentation(guy.Position, 15, false, true, true)
-- end)
end
local activated = false
local function Detonate()
activated = true
for i, v in pairs(c4s) do
task.wait(i/15)
coroutine.wrap(function()
v:SetAttribute("Active", 1)
local update = .4
local pl = v:FindFirstChild("PointLight")
while update > .1 do
    task.wait(update)
    update *= .9    
    tick.Parent = v
	tick.Parent = nil
    coroutine.wrap(function()
    pl.Enabled = true
    task.wait(update/2)
    pl.Enabled = false
    end)()
end
Explode(v)
task.wait(.05)
v:Destroy()
end)()
end
c4s = {}
task.wait(1)
activated = false
end
Tool0.Activated:Connect(function()
if #c4s ~= 0 and activated == false then
activate.Parent = Part1
activate.Parent = nil
Detonate()
end
end)
